# -*- coding: utf-8 -*-
"""Model 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a_q0gwb2Rq8wwBBW8JKlQwuYllQ_OLob
"""

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
from webcolors import CSS3_HEX_TO_NAMES, hex_to_rgb
from scipy.spatial import KDTree
import PIL.Image as Image
import cv2
from google.colab import drive

# Load only the first model
drive.mount('/content/drive')

# Define the path to your model file on Google Drive
model_path = '/content/drive/MyDrive/Colab Notebooks/model_sub'


# Load the model
sub_model = tf.keras.models.load_model(model_path)

sub_list = ["bottom","foot","top"]
# Function to convert RGB to color names using webcolors
def convert_rgb_to_names(rgb_tuple):
    css3_db = CSS3_HEX_TO_NAMES
    names = []
    rgb_values = []
    for color_hex, color_name in css3_db.items():
        names.append(color_name)
        rgb_values.append(hex_to_rgb(color_hex))

    kdt_db = KDTree(rgb_values)
    distance, index = kdt_db.query(rgb_tuple)
    return names[index]

# Function to get dominant color from an image
def get_cloth_color(image):
    max_score = 0.0001
    dominant_color = None
    for count,(r,g,b) in image.getcolors(image.size[0]*image.size[1]):
        saturation = colorsys.rgb_to_hsv(r/255.0, g/255.0, b/255.0)[1]
        y = min(abs(r*2104+g*4130+b*802+4096+131072)>>13,235)
        y = (y-16.0)/(235-16)
        if y > 0.9:
            continue
        score = (saturation+0.1)*count
        if score > max_score:
            max_score = score
            dominant_color = (r,g,b)

    return convert_rgb_to_names(dominant_color)

# Function to classify color of a clothing image
def color_classification(single_path):
    image = Image.open(single_path)
    image = image.convert('RGB')
    return get_cloth_color(image)

# Function to predict using the sub_model and return result
def single_classification(single_path):
    train_images = np.zeros((1,80,60,3))
    img = cv2.imread(single_path)
    if img.shape != (80,60,3):
        img = image.load_img(single_path, target_size=(80,60,3))
    train_images[0] = img
    result2 = sub_list[np.argmax(sub_model.predict(train_images))]
    return result2

# Example usage:
image_path = '/content/1594.jpg'
predicted_result = single_classification(image_path)
print(f"Predicted result from sub_model: {predicted_result}")

